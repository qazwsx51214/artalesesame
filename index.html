<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Artale å…¬å…±é »é“å¤–æ¥ç³»çµ±</title>
  <style>
    body {
      background-color: #fff;
      font-family: 'Segoe UI', sans-serif;
      color: #111;
      margin: 0;
      padding: 20px;
    }
    h2 {
      margin-bottom: 20px;
      color: #222;
    }
    #log {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 85vh;
      overflow-y: auto;
    }
    .msg-card {
      background-color: #fff;
      border-left: 4px solid #0078d7;
      padding: 12px 16px;
      border-radius: 6px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.08);
      position: relative;
    }
    .msg-header {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 4px;
      gap: 12px;
    }
    .timestamp {
      font-size: 0.9em;
      color: #888;
    }
    .channel-info, .profile-code {
      font-size: 0.85em;
      color: #333;
    }
    .channel-info {
      color: #0078d7;
      font-weight: bold;
    }
    .nickname {
      font-weight: bold;
      color: #0056b3;
    }
    .text {
      margin-top: 4px;
      white-space: pre-wrap;
      color: #111;
    }
    .tag-button {
      display: inline-block;
      background-color: #f2f2f2;
      color: #333;
      padding: 2px 8px;
      font-size: 0.75em;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 8px;
      transition: background 0.2s, color 0.2s;
      border: 1px solid #ccc;
    }
    .tag-button:hover {
      background-color: #0078d7;
      color: #fff;
    }
    .highlight {
      background: yellow;
      color: #d00;
      font-weight: bold;
      padding: 0 2px;
      border-radius: 2px;
    }
    #keyword-box {
      position: absolute;
      top: 24px;
      right: 32px;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #keyword-input {
      padding: 4px 8px;
      font-size: 1em;
      border: 1px solid #aaa;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <!-- pal-helper å·¥å…·æ¢ï¼ˆå³ä¸Šè§’ï¼‰ -->
  <div id="pal-toolbar" style="position:fixed;top:8px;right:32px;z-index:9999;background:rgba(255,255,255,0.95);border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.12);padding:10px 18px;display:flex;flex-direction:column;align-items:flex-start;gap:6px;">
    <div style="display:flex;align-items:center;gap:10px;">
      <label><input type="checkbox" id="pal-buy">è²·/æ”¶</label>
      <label><input type="checkbox" id="pal-sell">è³£/å‡º/å”®</label>
      <label>é—œéµå­—ï¼š</label>
      <input id="pal-keyword" type="text" placeholder="è¼¸å…¥é—œéµå­—ï¼ˆå¯ç©ºæ ¼åˆ†éš”å¤šçµ„ï¼‰" style="padding:4px 8px;">
      <label><input type="checkbox" id="pal-playsound" checked>æ’­æ”¾éŸ³æ•ˆ</label>
      <label><input type="checkbox" id="pal-autoscroll" checked>è‡ªå‹•æ²å‹•</label>
    </div>
    <div style="width:95%;margin-top:2px;">
      <input id="pal-code" type="text" placeholder="Codeé—œéµå­—:æ”¯æ´andæˆ–or(è¦ç©ºæ ¼)ã€æ‹¬è™Ÿã€‚ä¾‹å¦‚æ”¶ and (æ•æ· or å¹¸é‹)" style="width:100%;padding:4px 8px;">
    </div>
  </div>
  <h2>ğŸ“¡ Artale å…¬å…±é »é“å¤–æ¥ç³»çµ± (é¡¯ç¤º <span id="minutes-display">è¼‰å…¥ä¸­...</span> åˆ†é˜å…§è¨Šæ¯) 
    <input type="number" id="manual-minutes" min="1" max="1440" value="120" style="width: 60px; margin-left: 10px; padding: 4px;">
    <button onclick="setManualMinutes()" style="margin-left: 5px; padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8em;">âš™ï¸ è¨­å®š</button>
  </h2>
  <div id="log"></div>

  <script>
    // ====== å¯èª¿æ•´çš„é¡¯ç¤ºåˆ†é˜æ•¸ ======
    let BROADCAST_MINUTES = 120; // é è¨­å€¼120åˆ†é˜
    

    
    // æ›´æ–°é é¢é¡¯ç¤º
    function updateDisplay() {
      const displayElement = document.getElementById('minutes-display');
      if (displayElement) {
        displayElement.textContent = BROADCAST_MINUTES;
      }
      
      // åŒæ­¥æ›´æ–°æ‰‹å‹•è¼¸å…¥æ¡†
      const manualInput = document.getElementById('manual-minutes');
      if (manualInput && manualInput.value != BROADCAST_MINUTES) {
        manualInput.value = BROADCAST_MINUTES;
      }
    }
    

    
    // æ‰‹å‹•è¨­å®šåˆ†é˜æ•¸ä¸¦é‡æ–°è¼‰å…¥æ­·å²è¨Šæ¯
    async function setManualMinutes() {
      const input = document.getElementById('manual-minutes');
      const minutes = parseInt(input.value);
      
      if (minutes > 0 && minutes <= 1440) {
        BROADCAST_MINUTES = minutes;
        console.log(`âš™ï¸ æ‰‹å‹•è¨­å®šï¼šé¡¯ç¤º ${minutes} åˆ†é˜å…§çš„è¨Šæ¯`);
        updateDisplay();
        
        // ç›´æ¥è¼‰å…¥æ­·å²è¨Šæ¯
        await loadHistoryMessages();
      } else {
        alert('è«‹è¼¸å…¥1åˆ°1440ä¹‹é–“çš„æ•¸å­—ï¼ˆä»£è¡¨åˆ†é˜æ•¸ï¼‰');
        input.value = BROADCAST_MINUTES;
      }
    }
    

    
    // å¾æ­·å²æª”æ¡ˆè¼‰å…¥è¨Šæ¯
    async function loadHistoryMessages() {
      try {
        console.log('ğŸ“– é–‹å§‹è¼‰å…¥æ­·å²è¨Šæ¯...');
        
        // æ¸…ç©ºç¾æœ‰å…§å®¹
        const logDiv = document.getElementById("log");
        logDiv.innerHTML = '';
        
        const response = await fetch('history_messages.json?' + Date.now());
        
        if (!response.ok) {
          console.log('ğŸ“ æ­·å²æª”æ¡ˆä¸å­˜åœ¨æˆ–ç„¡æ³•è®€å–');
          return;
        }
        
        const text = await response.text();
        const lines = text.trim().split('\n');
        const now = Date.now();
        const maxAge = BROADCAST_MINUTES * 60 * 1000;
        let loadedCount = 0;
        let displayedCount = 0;
        
        const validMessages = [];
        
        for (const line of lines) {
          if (line.trim()) {
            try {
              const msg = JSON.parse(line);
              loadedCount++;
              
              // æª¢æŸ¥æ™‚é–“ç¯„åœ
              const timestamp = msg.timestamp || "";
              if (timestamp) {
                try {
                  const timeStr = timestamp.replace(/[\[\]]/g, '');
                  const msgTime = new Date(timeStr);
                  
                  if (isFinite(msgTime.getTime())) {
                    const diffMs = now - msgTime.getTime();
                    if (diffMs <= maxAge) {
                      // æª¢æŸ¥æ˜¯å¦ç¬¦åˆéæ¿¾æ¢ä»¶
                      const state = getFilterState();
                      const hasFilter = state.code !== '' || state.buy || state.sell || state.keywords.length > 0;
                      
                      if (!hasFilter || isMessageHighlighted(msg)) {
                        validMessages.push(msg);
                        displayedCount++;
                      }
                    }
                  }
                } catch (e) {
                  console.log('âš ï¸ ç„¡æ•ˆæ™‚é–“æ ¼å¼:', timestamp);
                }
              }
            } catch (e) {
              console.log('âŒ JSONè§£æå¤±æ•—:', line);
            }
          }
        }
        
        // æŒ‰æ™‚é–“é †åºæ’åºï¼ˆæœ€èˆŠçš„åœ¨å‰é¢ï¼‰
        validMessages.sort((a, b) => {
          try {
            const timeA = new Date(a.timestamp.replace(/[\[\]]/g, ''));
            const timeB = new Date(b.timestamp.replace(/[\[\]]/g, ''));
            return timeA.getTime() - timeB.getTime();
          } catch (e) {
            return 0;
          }
        });
        
        // é¡¯ç¤ºè¨Šæ¯
        validMessages.forEach(msg => {
          displayHistoryMessage(msg);
        });
        
        // æ›´æ–° allMessages
        allMessages = [...validMessages];
        
        console.log(`ğŸ“Š è¼‰å…¥çµ±è¨ˆ: è®€å– ${loadedCount} æ¢è¨Šæ¯ï¼Œé¡¯ç¤º ${displayedCount} æ¢ç¬¦åˆ ${BROADCAST_MINUTES} åˆ†é˜å…§çš„è¨Šæ¯`);
        scrollToBottom();
      } catch (e) {
        console.log('âŒ è¼‰å…¥æ­·å²è¨Šæ¯å¤±æ•—:', e);
      }
    }
    
    // é¡¯ç¤ºæ­·å²è¨Šæ¯
    function displayHistoryMessage(data) {
      const logDiv = document.getElementById("log");
      const ts = data.timestamp || "";
      const nick = data.Nickname || "";
      const rawText = data.Text || "";
      const text = highlightText(rawText);
      const channel = data.Channel || "";
      const profileCode = data.ProfileCode || "";
      const friendTag = `${nick}#${profileCode}`;

      const card = document.createElement("div");
      card.className = "msg-card";

      card.innerHTML = `
        <div class="msg-header">
          <div class="timestamp">${ts}</div>
          <div class="channel-info">${channel}</div>
          <div class="profile-code">è­˜åˆ¥ç¢¼: ${profileCode}</div>
          <div class="tag-button" onclick="copyToClipboard('${friendTag}', this)">è¤‡è£½å¥½å‹</div>
        </div>
        <div><span class="nickname">${nick}</span>: <span class="text">${text}</span></div>
      `;

      logDiv.appendChild(card);
    }
    
    // åˆå§‹åŒ–é¡¯ç¤º
    updateDisplay();
    
    // è¼‰å…¥æ­·å²è¨Šæ¯
    setTimeout(async () => {
      await loadHistoryMessages();
    }, 1000);
    
    // å®šæœŸæ¸…ç†èˆŠè¨Šæ¯ï¼ˆæ¯30ç§’æ¸…ç†ä¸€æ¬¡ï¼Œé™ä½é »ç‡ï¼‰
    setInterval(() => {
      cleanupOldMessages();
    }, 30000);
    

    
    // æ¸…ç†è¶…éæ™‚é–“çš„èˆŠè¨Šæ¯
    function cleanupOldMessages() {
      const logDiv = document.getElementById("log");
      const cards = logDiv.querySelectorAll('.msg-card');
      let removedCount = 0;
      const now = Date.now();
      const maxAge = BROADCAST_MINUTES * 60 * 1000; // æ¯«ç§’
      
      cards.forEach(card => {
        const timestampElement = card.querySelector('.timestamp');
        if (timestampElement) {
          const timestampText = timestampElement.textContent.trim().replace(/[\[\]]/g, '');
          try {
            const msgTime = new Date(timestampText);
            if (isFinite(msgTime.getTime())) {
              const diffMs = now - msgTime.getTime();
              if (diffMs > maxAge) {
                card.remove();
                removedCount++;
              }
            }
          } catch (e) {
            card.remove();
            removedCount++;
          }
        }
      });
      
      if (removedCount > 0) {
        console.log(`ğŸ§¹ æ¸…ç†äº† ${removedCount} æ¢è¶…é ${BROADCAST_MINUTES} åˆ†é˜çš„èˆŠè¨Šæ¯`);
      }
    }

    // ===== pal-helper åŠŸèƒ½æ•´åˆ =====
    let audio = null;
    function playSound() {
      if (!audio) {
        audio = document.createElement('audio');
        audio.src = 'sound.wav';
        document.body.appendChild(audio);
      }
      audio.currentTime = 0;
      audio.play();
    }
    
    // è§£æå¸ƒæ—é‹ç®—å¼ï¼ˆæ”¯æ´and/or/æ‹¬è™Ÿå·¢ç‹€ï¼‰
    function parseBooleanExpr(expr) {
      const tokens = [];
      const re = /\(|\)|\band\b|\bor\b|[^\s()]+/gi;
      let m;
      while ((m = re.exec(expr))) {
        tokens.push(m[0]);
      }
      let pos = 0;
      function parseExpr() {
        let node = parseTerm();
        while (tokens[pos] && /^or$/i.test(tokens[pos])) {
          pos++;
          node = { type: 'or', left: node, right: parseTerm() };
        }
        return node;
      }
      function parseTerm() {
        let node = parseFactor();
        while (tokens[pos] && /^and$/i.test(tokens[pos])) {
          pos++;
          node = { type: 'and', left: node, right: parseFactor() };
        }
        return node;
      }
      function parseFactor() {
        if (tokens[pos] === '(') {
          pos++;
          const node = parseExpr();
          if (tokens[pos] !== ')') throw new Error('æ‹¬è™Ÿä¸åŒ¹é…');
          pos++;
          return node;
        } else {
          return { type: 'word', value: tokens[pos++] };
        }
      }
      const ast = parseExpr();
      if (pos !== tokens.length) throw new Error('èªæ³•éŒ¯èª¤');
      return ast;
    }
    
    function matchBooleanExpr(ast, text) {
      if (!ast) return false;
      if (ast.type === 'word') return text.includes(ast.value);
      if (ast.type === 'and') return matchBooleanExpr(ast.left, text) && matchBooleanExpr(ast.right, text);
      if (ast.type === 'or') return matchBooleanExpr(ast.left, text) || matchBooleanExpr(ast.right, text);
      return false;
    }
    
    // pal-helper ç‹€æ…‹
    function getFilterState() {
      return {
        buy: document.getElementById('pal-buy').checked,
        sell: document.getElementById('pal-sell').checked,
        keywords: document.getElementById('pal-keyword').value.trim().split(/\s+/).filter(Boolean),
        code: document.getElementById('pal-code').value.trim(),
        playsound: document.getElementById('pal-playsound').checked
      };
    }
    
    // æª¢æŸ¥æ˜¯å¦åœ¨åº•éƒ¨
    function isAtBottom() {
      return logDiv.scrollHeight - logDiv.scrollTop - logDiv.clientHeight < 2;
    }
    
    // è‡ªå‹•æ²å‹•åˆ°åº•éƒ¨
    function scrollToBottom() {
      if (document.getElementById('pal-autoscroll').checked) {
        logDiv.scrollTop = logDiv.scrollHeight;
      }
    }
    
    // æª¢æŸ¥è¨Šæ¯æ˜¯å¦ç¬¦åˆéæ¿¾æ¢ä»¶
    function isMessageHighlighted(data) {
      const state = getFilterState();
      let mainWords = [];
      if (state.buy) mainWords.push('è²·', 'æ”¶');
      if (state.sell) mainWords.push('è³£', 'å‡º', 'å”®');
      const rawText = data.Text || '';
      
      // å¦‚æœæ²’æœ‰ä»»ä½•éæ¿¾æ¢ä»¶ï¼Œä¸ç®—é«˜äº®
      if (state.code === '' && mainWords.length === 0 && state.keywords.length === 0) {
        return false;
      }
      
      if (state.code) {
        let ast;
        try {
          ast = parseBooleanExpr(state.code);
        } catch (e) {
          return false;
        }
        return matchBooleanExpr(ast, rawText);
      }
      if (mainWords.length === 0) {
        if (state.keywords.length === 0) return false;
        const regex = new RegExp(state.keywords.map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'i');
        return regex.test(rawText);
      } else {
        const mainRegex = new RegExp(mainWords.map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'i');
        const keywordRegex = state.keywords.length > 0 ? new RegExp(state.keywords.map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'i') : null;
        return mainRegex.test(rawText) && (!keywordRegex || keywordRegex.test(rawText));
      }
    }
    
    // é«˜äº®é—œéµå­—
    function highlightText(text) {
      const state = getFilterState();
      let result = text;
      
      // è™•ç†è²·/è³£é—œéµå­—
      let mainWords = [];
      if (state.buy) mainWords.push('è²·', 'æ”¶');
      if (state.sell) mainWords.push('è³£', 'å‡º', 'å”®');
      
      if (mainWords.length > 0) {
        const mainRegex = new RegExp(mainWords.map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'gi');
        result = result.replace(mainRegex, m => `<span class="highlight">${m}</span>`);
      }
      
      // è™•ç†ä¸€èˆ¬é—œéµå­—
      if (state.keywords.length > 0) {
        const keywordRegex = new RegExp(state.keywords.map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'gi');
        result = result.replace(keywordRegex, m => `<span class="highlight">${m}</span>`);
      }
      
      // è™•ç† code æœå°‹çš„é—œéµå­—
      if (state.code) {
        try {
          const ast = parseBooleanExpr(state.code);
          const codeWords = new Set();
          collectWords(ast, codeWords);
          codeWords.forEach(word => {
            const wordRegex = new RegExp(word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            result = result.replace(wordRegex, m => `<span class="highlight">${m}</span>`);
          });
        } catch (e) {
          // å¦‚æœè§£æå¤±æ•—ï¼Œå°±ç•¶ä½œä¸€èˆ¬é—œéµå­—è™•ç†
          const codeRegex = new RegExp(state.code.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
          result = result.replace(codeRegex, m => `<span class="highlight">${m}</span>`);
        }
      }
      
      return result;
    }
    
    // æ”¶é›†å¸ƒæ—é‹ç®—å¼ä¸­çš„æ‰€æœ‰é—œéµå­—
    function collectWords(ast, set) {
      if (!ast) return;
      if (ast.type === 'word') set.add(ast.value);
      if (ast.left) collectWords(ast.left, set);
      if (ast.right) collectWords(ast.right, set);
    }

    const logDiv = document.getElementById("log");
    const ws = new WebSocket("ws://localhost:8765");
    
    // å„²å­˜æ‰€æœ‰è¨Šæ¯çš„é™£åˆ—
    let allMessages = [];
    
    // é‡æ–°æ¸²æŸ“æ‰€æœ‰è¨Šæ¯ï¼ˆç”¨æ–¼éæ¿¾ï¼‰
    function renderAllMessages() {
      const logDiv = document.getElementById("log");
      logDiv.innerHTML = '';
      
      const state = getFilterState();
      const hasFilter = state.code !== '' || state.buy || state.sell || state.keywords.length > 0;
      const now = Date.now();
      
      allMessages.forEach(data => {
        // éæ¿¾è¶…é BROADCAST_MINUTES çš„è¨Šæ¯
        const timestamp = data.timestamp || "";
        if (timestamp) {
          try {
            const timeStr = timestamp.replace(/[\[\]]/g, '');
            const msgTime = new Date(timeStr);
            if (isFinite(msgTime.getTime())) {
              if (now - msgTime.getTime() > BROADCAST_MINUTES * 60 * 1000) return;
            }
          } catch (e) {}
        }
        
        // å¦‚æœæ²’æœ‰éæ¿¾æ¢ä»¶ï¼Œé¡¯ç¤ºæ‰€æœ‰è¨Šæ¯
        if (!hasFilter) {
          displayHistoryMessage(data);
          return;
        }
        
        // æª¢æŸ¥æ˜¯å¦ç¬¦åˆéæ¿¾æ¢ä»¶
        if (isMessageHighlighted(data)) {
          displayHistoryMessage(data);
        }
      });
      
      scrollToBottom();
    }

    ws.onopen = () => console.log("âœ… WebSocket é€£ç·šæˆåŠŸ");
    ws.onclose = () => console.log("ğŸ”Œ WebSocket å·²é—œé–‰");

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      allMessages.push(data);
      
      // æª¢æŸ¥æ–°è¨Šæ¯æ˜¯å¦åœ¨æ™‚é–“ç¯„åœå…§
      const timestamp = data.timestamp || "";
      if (timestamp) {
        try {
          const timeStr = timestamp.replace(/[\[\]]/g, '');
          const msgTime = new Date(timeStr);
          if (isFinite(msgTime.getTime())) {
            if (Date.now() - msgTime.getTime() > BROADCAST_MINUTES * 60 * 1000) return;
          }
        } catch (e) {}
      }
      
      // æª¢æŸ¥æ˜¯å¦æœ‰ä»»ä½•éæ¿¾æ¢ä»¶
      const state = getFilterState();
      const hasFilter = state.code !== '' || state.buy || state.sell || state.keywords.length > 0;
      
      // å¦‚æœæ²’æœ‰éæ¿¾æ¢ä»¶ï¼Œç›´æ¥é¡¯ç¤ºæ‰€æœ‰æ–°è¨Šæ¯
      if (!hasFilter) {
        displayHistoryMessage(data);
        scrollToBottom();
        return;
      }
      
      // å¦‚æœæœ‰éæ¿¾æ¢ä»¶ï¼Œæª¢æŸ¥æ˜¯å¦ç¬¦åˆ
      if (isMessageHighlighted(data)) {
        displayHistoryMessage(data);
        scrollToBottom();
        
        // æ’­æ”¾éŸ³æ•ˆ
                 if (state.playsound) {
           playSound();
         }
       }
     };

    // ç›£è½æ²å‹•äº‹ä»¶
    logDiv.addEventListener('scroll', () => {
      const autoscrollCheckbox = document.getElementById('pal-autoscroll');
      if (isAtBottom()) {
        // å¦‚æœåœ¨åº•éƒ¨ï¼Œè‡ªå‹•æ‰“å‹¾
        if (!autoscrollCheckbox.checked) {
          autoscrollCheckbox.checked = true;
        }
      } else {
        // å¦‚æœä¸åœ¨åº•éƒ¨ï¼Œå–æ¶ˆæ‰“å‹¾
        if (autoscrollCheckbox.checked) {
          autoscrollCheckbox.checked = false;
        }
      }
    });

    // æ·»åŠ äº‹ä»¶ç›£è½å™¨
    document.getElementById('pal-buy').addEventListener('change', renderAllMessages);
    document.getElementById('pal-sell').addEventListener('change', renderAllMessages);
    document.getElementById('pal-keyword').addEventListener('input', renderAllMessages);
    document.getElementById('pal-code').addEventListener('input', renderAllMessages);

    // å®šæ™‚è‡ªå‹•åˆ·æ–°è¨Šæ¯ï¼Œç§»é™¤è¶…æ™‚çš„å»£æ’­
    setInterval(renderAllMessages, 10000); // æ¯10ç§’è‡ªå‹•åˆ·æ–°ä¸€æ¬¡

    function copyToClipboard(text, el) {
      navigator.clipboard.writeText(text).then(() => {
        const original = el.textContent;
        el.textContent = "âœ… å·²è¤‡è£½";
        setTimeout(() => el.textContent = original, 1200);
      });
    }
  </script>
</body>
</html>
